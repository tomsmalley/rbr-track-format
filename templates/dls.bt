// Scripts, cameras, pacenotes?

// If there are errors loading the dls file, the game creates dlserrors.log.
// For example:
// 12-Sep-20 16:58:14 Loading DLS data of stage 71,
//   animationIdsOffset = 0x658c,
//   count = 0,
//   animation id name offsets out of range: NONE,
//   animationSetsOffset = 0x38,
//   count = 1,
//   anim set header 0,
//   replay camera channels out of range: 3(60351)
// 12-Sep-20 17:24:31  RBR crashed while loading data

// Common types

typedef struct Position {
  float x;
  float y;
  float z;
};

// File starts here

char header[0x8] <comment="DATAANIM backwards">;
int unknown_1;
int unknown_2;
// TODO check if these correspond to anything known in ghidra
struct Offsets {
  int animation_sets <format=hex>;
  int unknown[8] <format=hex>;
  int animation_ids <format=hex>;
} offsets;

struct Sizes {
  int unknown_1;
  int unknown_2;
  int unknown_3;
  int unknown_4;
  int camera_channel_count;
  int camera_line_point_count;
  int b_count;
  int unknown_5[13];
} sizes;

// Camera ID array.
// Tested on Rally School and New Bobs.
typedef struct {
  int camera_id <format=hex>;
  int unknown;
} CameraChannel;
CameraChannel camera_channels[sizes.camera_channel_count];

// This defines the positions along the driveline at which to switch to certain
// replay cameras.
typedef struct {
  int camera_channel; // Index into the camera ID array
  float distance_travelled;
  // Seems to be one or zero, but also doesn't have an effect?
  // This is always set to 1 a tiny bit before it's set to 0.
  int unknown;
} ReplayCameraPoint;
ReplayCameraPoint replay_camera_line[sizes.camera_line_point_count];

typedef struct {
  int unknown_1;
  float unknown_2;
  float unknown_3;
} B;
B bs[sizes.b_count];

struct CameraSettings {
  typedef struct {
    int camera_id <format=hex>;
    // 4 = ???
    // 8 = ???
    // 12 = fov key frame
    // 16 = ???
    int mode;
    int fov_change_count;
    int unknown_4;
    typedef struct {
      int unknown_5;
      float fov_driveline_distance;
      float fov;
      float unknown_6;
      float unknown_7;
      float unknown_8;
      float unknown_9;
    } FovChange;
    FovChange fov_changes[fov_change_count];
  } CameraSettingsItem;
  CameraSettingsItem fov_bits[16] <optimize=false>;
} camera_settings;

float fov_rest[2];

// 0x9AC for rally school
int test_size; // Only tested for rally school
typedef struct {
  float unknown_1;
  int unknown_2;
  float unknown_3;
  float unknown_4;
  float unknown_5[3];
} Test;
Test test_bits[test_size];

int pad_test_2[3];
int test_size_2;
Test test_bits_2[test_size_2];

int pad_test_3[3];
int test_size_3;
Test test_bits_3[test_size_3];

int pad_test_4[3];
int test_size_4;
Test test_bits_4[test_size_4];

float gap[122];

// 0x43C8 for rally school
int camera_position_count;
typedef struct {
  int camera_id <format=hex>;
  int camera_id_2 <format=hex>;
  int unknown[2];
  // Position of camera in world coordinates
  Position position;
  // All angles are specified in degrees. This is only used for fixed cameras.
  struct Angle {
    // Angle from horizontal. Negative looks upwards.
    float pitch;
    // Angle from horizontal. Positive tilts camera clockwise.
    float roll;
    // 0 Looks in positive Y direction?
    // Positive values turn camera clockwise in plan view.
    float yaw;
  } angle;
  float unknown_5[3]; // All ones?
  int unknown_6;
} CameraPosition;
CameraPosition camera_positions[camera_position_count];

int unknown_3[3];

// 0x4838 for rally school
int unknown_4_count;
// These values are guessed, I have no confirmation of them yet.
typedef struct {
  float unknown_1;
  Position position;
  typedef struct {
    float v[3];
  } Vector3;
  Vector3 unknown_vector_1;
  // Seems to be a negated version of the vector above.
  Vector3 unknown_vector_2;
  float driveline_position;
} SomeFloats;
SomeFloats unknown_4[unknown_4_count];

// 0x63BC for rally school
int camera_specs_count;
typedef struct {
  int camera_id <format=hex>;
  // mode=0: Fixed camera - uses the angle specified in the camera position section.
  // mode=-1: Look at car
  // mode=CameraID: Look at the position of another camera
  // Other modes appear to be interpreted as 0.
  int mode <format=hex>;
  float unknown_2;
  // 0: no wobble. Sensible values are less than 0.5.
  float wobble_factor;
  float unknown_4;
  float unknown_5;
} CameraSpec;
CameraSpec camera_specs[camera_specs_count];

float rest[9];

char driveline[12];

if (driveline != "Driveline") {
  return "Driveline string not found";
} else if (header != "MINAATAD") {
  return "Incorrect header";
} else {
  return "Parse OK";
}